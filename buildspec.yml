---
version: 0.2

env:
  variables:
    AWS_REGION: "us-east-1"
    AWS_ACCOUNT_ID: "057959860487"
    ECR_REPO_NAME: "multicloud-prowler-repo"
    IMAGE_TAG: "latest"
    # Vari√°veis de Task Definition (AJUSTE ESTES VALORES!)
    TASK_FAMILY: "multicloud-prowler-task"
    CONTAINER_NAME: "prowler-runner"

phases:
  install:
    commands:
      # Instala√ß√£o: Garante que o jq esteja dispon√≠vel
      - echo "=== Instalando e Validando Depend√™ncias (jq) ==="
      - if ! command -v jq &> /dev/null; then echo "Instalando jq..."; apt-get update && apt-get install -y jq; fi
      - aws --version
      - docker --version

  pre_build:
    commands:
      # === 1. LOGIN E DEFINI√á√ïES ===
      - echo "=== Login no ECR e Defini√ß√µes ==="
      - FULL_ECR_URI="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com"
      - NEW_IMAGE_URI="$FULL_ECR_URI/$ECR_REPO_NAME:$IMAGE_TAG"
      - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin "$FULL_ECR_URI"

      - echo "=== 2. Cria√ß√£o dos Scripts de Execu√ß√£o e Deploy ==="
      
      # -----------------------------------------------------
      # A) CRIA√á√ÉO: run-prowler.sh (Script de Entrada do Container)
      # -----------------------------------------------------
      - cat <<EOF > run-prowler.sh
#!/bin/bash
set -euo pipefail

# CORRE√á√ÉO CR√çTICA: For√ßa o PATH para que o 'prowler' seja encontrado no Entrypoint
export PATH="/usr/local/bin:/usr/local/sbin:/usr/sbin:/usr/bin:/sbin:/bin:/root/.local/bin"

# === DIAGN√ìSTICO INICIAL ===
if ! command -v prowler &> /dev/null; then
    echo "‚ùå Erro Cr√≠tico: 'prowler' n√£o encontrado no PATH! A imagem Docker falhou."
    exit 1
fi

echo "‚úÖ Prowler pronto para uso: \$(command -v prowler)"
prowler --version || echo "‚ö†Ô∏è N√£o foi poss√≠vel exibir a vers√£o do prowler."

echo "üõ∞Ô∏è === Iniciando execu√ß√£o do Prowler Runner ==="
echo "üìÇ Diret√≥rio atual: \$(pwd)"
echo "üë§ Usu√°rio atual: \$(whoami)"
echo "üîß PATH atual: \$PATH"

# === VARI√ÅVEIS OBRIGAT√ìRIAS ===
: "\${CLOUD_PROVIDER:?‚ùå CLOUD_PROVIDER n√£o definido (aws | azure | gcp)}"
: "\${TARGET_ACCOUNTS:?‚ùå TARGET_ACCOUNTS n√£o definido (IDs separados por v√≠rgula ou ALL)}"

REGION="\${AWS_REGION:-us-east-1}"
BUCKET="my-prowler-results"
TIMESTAMP=\$(date +%Y%m%d%H%M)
OUTPUT_DIR="/tmp"
OUTPUTS=()

CLOUD_PROVIDER=\$(echo "\$CLOUD_PROVIDER" | tr '[:upper:]' '[:lower:]')

upload_to_s3() {
    local file="\$1"
    local account="\$2"
    local dest="s3://\${BUCKET}/\${CLOUD_PROVIDER}/\${account}/\${TIMESTAMP}/\$(basename "\$file")"
    echo "üì§ Enviando \$file ‚Üí \$dest"
    aws s3 cp "\$file" "\$dest" --acl bucket-owner-full-control || {
        echo "‚ùå Falha no upload de \$file"
        return 1
    }
}

run_prowler_generic() {
    local provider="\$1"
    local id="\$2"
    shift 2
    local extra_args=(\"\$@\")

    echo "üöÄ Executando Prowler para \${provider^^} ‚Üí \$id"
    local OUT_FILE="\${OUTPUT_DIR}/prowler-output-\${id}-\${TIMESTAMP}.json"

    # Chamada direta e limpa para 'prowler'
    prowler "\$provider" "\${extra_args[@]}" \
        --output-formats json-asff \
        --output-filename "\$(basename "\$OUT_FILE" .json)" \
        --output-directory "\$OUTPUT_DIR" \
        --ignore-exit-code-3

    if [[ -f "\$OUT_FILE" ]]; then
        echo "‚úÖ Arquivo gerado: \$OUT_FILE"
        OUTPUTS+=("\$OUT_FILE")
        upload_to_s3 "\$OUT_FILE" "\$id"
    else
        echo "‚ùå Arquivo n√£o encontrado para \$id"
    }
}

# === AWS ===
if [[ "\$CLOUD_PROVIDER" == "aws" ]]; then
    echo "‚òÅÔ∏è  Selecionado AWS"
    if [[ "\$TARGET_ACCOUNTS" == "ALL" ]]; then
        echo "üîé Buscando contas AWS no SSM..."
        TARGET_ACCOUNTS=\$(aws ssm get-parameter \
            --name "/prowler/aws/accounts" \
            --query "Parameter.Value" \
            --output text)
    fi

    for ACCOUNT_ID in \$(echo "\$TARGET_ACCOUNTS" | tr ',' ' '); do
        echo "üéØ Conta alvo: \$ACCOUNT_ID"
        CREDS=\$(aws sts assume-role \
            --role-arn arn:aws:iam::\${ACCOUNT_ID}:role/ProwlerAuditRole \
            --role-session-name prowler-session)
        export AWS_ACCESS_KEY_ID=\$(echo "\$CREDS" | jq -r .Credentials.AccessKeyId)
        export AWS_SECRET_ACCESS_KEY=\$(echo "\$CREDS" | jq -r .Credentials.SecretAccessKey)
        export AWS_SESSION_TOKEN=\$(echo "\$CREDS" | jq -r .Credentials.SessionToken)

        run_prowler_generic aws "\$ACCOUNT_ID" --region "\$REGION"

        unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
    done
fi

# === AZURE ===
if [[ "\$CLOUD_PROVIDER" == "azure" ]]; then
    echo "‚òÅÔ∏è  Selecionado Azure"
    if [[ "\$TARGET_ACCOUNTS" == "ALL" ]]; then
        echo "üîé Buscando subscriptions Azure no SSM..."
        TARGET_ACCOUNTS=\$(aws ssm get-parameter \
            --name "/prowler/azure/subscriptions" \
            --query "Parameter.Value" \
            --output text)
    fi

    for SUB in \$(echo "\$TARGET_ACCOUNTS" | tr ',' ' '); do
        run_prowler_generic azure "\$SUB" --subscription-id "\$SUB"
    done
fi

# === GCP ===
if [[ "\$CLOUD_PROVIDER" == "gcp" ]]; then
    echo "‚òÅÔ∏è  Selecionado GCP"
    if [[ "\$TARGET_ACCOUNTS" == "ALL" ]]; then
        echo "üîé Buscando projetos GCP no SSM..."
        TARGET_ACCOUNTS=\$(aws ssm get-parameter \
            --name "/prowler/gcp/projects" \
            --query "Parameter.Value" \
            --output text)
    fi

    echo "üîë Recuperando credenciais de service account..."
    aws ssm get-parameter \
        --name "/prowler/gcp/michel/serviceAccountKey" \
        --with-decryption \
        --query "Parameter.Value" \
        --output text | base64 -d > /tmp/prowler-sa.json
    export GOOGLE_APPLICATION_CREDENTIALS="/tmp/prowler-sa.json"

    for PROJECT in \$(echo "\$TARGET_ACCOUNTS" | tr ',' ' '); do
        run_prowler_generic gcp "\$PROJECT" --project-id "\$PROJECT"
    \done
fi

echo "üßæ === Execu√ß√£o finalizada. Relat√≥rios gerados: ==="
printf '%%s\n' "\${OUTPUTS[@]}"
EOF

      # -----------------------------------------------------
      # B) CRIA√á√ÉO: update-task-definition.sh (Script de Deploy)
      # -----------------------------------------------------
      - cat <<EOF > update-task-definition.sh
#!/bin/bash
set -euo pipefail

# Vari√°veis passadas do CodeBuild ENV
AWS_REGION=\$AWS_REGION
TASK_FAMILY=\$TASK_FAMILY
CONTAINER_NAME=\$CONTAINER_NAME
NEW_IMAGE_URI=\$NEW_IMAGE_URI

TASK_DEF_FILE="task-definition-new.json"
TASK_DEF_UPDATED_FILE="task-definition-updated.json"

echo "=== 1. Validando e Puxando Task Definition ==="
LATEST_TASK_ARN=\$(aws ecs list-task-definitions \
    --family-prefix "\$TASK_FAMILY" \
    --status ACTIVE \
    --sort DESC \
    --max-items 1 \
    --query 'taskDefinitionArns[0]' \
    --output text)

if [ "\$LATEST_TASK_ARN" = "None" ] || [ -z "\$LATEST_TASK_ARN" ]; then
    echo "‚ùå ERRO: Fam√≠lia de Tarefa '\$TASK_FAMILY' n√£o encontrada. Abortando atualiza√ß√£o."
    exit 1
fi

echo "‚úÖ ARN ativo: \$LATEST_TASK_ARN. Puxando JSON..."

aws ecs describe-task-definition \
    --task-definition "\$LATEST_TASK_ARN" \
    --query 'taskDefinition' \
    | jq 'del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities)' \
    > "\$TASK_DEF_FILE"

echo "=== 2. Atualizando URI da Imagem (\$CONTAINER_NAME) ==="

jq --arg img "\$NEW_IMAGE_URI" \
   --arg name "\$CONTAINER_NAME" \
   '(.containerDefinitions[] | select(.name == \$name).image) = \$img' \
   "\$TASK_DEF_FILE" > "\$TASK_DEF_UPDATED_FILE"

UPDATED_COUNT=\$(cat "\$TASK_DEF_UPDATED_FILE" | jq "(.containerDefinitions[] | select(.name == \"\$CONTAINER_NAME\") | .image) | select(.)" | wc -l)

if [ "\$UPDATED_COUNT" -eq 0 ]; then
    echo "‚ùå ERRO: N√£o foi poss√≠vel atualizar o cont√™iner '\$CONTAINER_NAME'. Nome incorreto?"
    exit 1
fi

echo "‚úÖ URI da imagem atualizada para \$NEW_IMAGE_URI."

echo "=== 3. Registrando Nova Revis√£o ==="

NEW_REVISION_ARN=\$(aws ecs register-task-definition \
    --cli-input-json file://"\$TASK_DEF_UPDATED_FILE" \
    --query 'taskDefinition.taskDefinitionArn' \
    --output text)

echo "====================================================="
echo "           ‚úÖ SUCESSO! NOVA REVIS√ÉO CRIADA"
echo "Nova Revis√£o ARN: \$NEW_REVISION_ARN"
echo "====================================================="

rm "\$TASK_DEF_FILE" "\$TASK_DEF_UPDATED_FILE"
EOF

      # === 3. FINALIZA√á√ÉO DA CRIA√á√ÉO DE SCRIPTS ===
      - chmod +x run-prowler.sh update-task-definition.sh

  build:
    commands:
      # Build: Focado em construir e taguear
      - echo "=== Construindo imagem Docker ==="
      - docker build -t prowler-repo-local -f Dockerfile.prowler .
      - docker tag prowler-repo-local:latest "$NEW_IMAGE_URI"

  post_build:
    commands:
      # Deploy: Focado em push e atualiza√ß√£o da Task Definition
      - echo "=== 1. Publicando imagem no ECR ==="
      - docker push "$NEW_IMAGE_URI"

      - echo "=== 2. Executando Atualiza√ß√£o da Defini√ß√£o de Tarefa ECS ==="
      - export NEW_IMAGE_URI="$NEW_IMAGE_URI" # Garante que a vari√°vel seja passada
      - ./update-task-definition.sh

      - echo "=== Build e Deploy Conclu√≠dos com Sucesso ==="

artifacts:
  files: []
